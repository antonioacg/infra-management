# Bootstrap State Infrastructure - Phase 1 ONLY
# Purpose: Foundation infrastructure for enterprise platform
# Creates: k3s + MinIO + PostgreSQL ONLY (foundation only)

terraform {
  required_version = ">= 1.0"

  required_providers {
    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = "~> 2.0"
    }
    helm = {
      source  = "hashicorp/helm"
      version = "~> 2.0"
    }
    null = {
      source  = "hashicorp/null"
      version = "~> 3.0"
    }
  }
}

# Bootstrap namespace
# NOTE: k3s installation handled by bootstrap-phase1.sh script
resource "kubernetes_namespace" "bootstrap" {
  metadata {
    name = "bootstrap"
  }
}

# MinIO credentials are generated by bootstrap script
# and passed as variables to this Terraform configuration

# MinIO for Terraform state storage
resource "helm_release" "bootstrap_minio" {
  name       = "bootstrap-minio"
  repository = "https://charts.min.io/"
  chart      = "minio"
  namespace  = "bootstrap"
  version    = "5.0.15"

  create_namespace = true

  values = [yamlencode({
    mode = var.node_count == 1 ? "standalone" : "distributed"
    replicas = var.node_count
    rootUser     = var.minio_root_user
    rootPassword = var.minio_root_password
    buckets = [
      {
        name   = "terraform-state"
        policy = "none"
        purge  = false
      },
      {
        name   = "vault-storage"
        policy = "none"
        purge  = false
      },
      {
        name   = "vault-backups"
        policy = "none"
        purge  = false
      }
    ]
    makeBucketJob = {
      securityContext = {
        enabled = true
      }
    }
    persistence = {
      enabled      = true
      size         = var.minio_storage_size
      storageClass = "local-path"
    }
    service = {
      type = "ClusterIP"
      ports = {
        api     = 9000
        console = 9001
      }
    }
    resources = {
      requests = {
        memory = "256Mi"
        cpu    = "100m"
      }
      limits = {
        memory = "512Mi"
        cpu    = "500m"
      }
    }
  })]

  depends_on = [kubernetes_namespace.bootstrap]
}

# CloudNativePG Operator for PostgreSQL management
resource "helm_release" "cloudnative_pg_operator" {
  name       = "cloudnative-pg"
  repository = "https://cloudnative-pg.github.io/charts"
  chart      = "cloudnative-pg"
  namespace  = "cnpg-system"
  version    = "0.22.1"

  create_namespace = true
  wait             = true
  timeout          = 600

  depends_on = [kubernetes_namespace.bootstrap]
}

# PostgreSQL cluster for state locking (ARM64 compatible)
# Note: Deployed via null_resource because kubernetes_manifest validates CRDs at plan time
resource "null_resource" "bootstrap_postgresql" {
  provisioner "local-exec" {
    command = <<-EOT
      # Wait for operator to be ready
      echo "Waiting for CloudNativePG operator to be ready..."
      for i in {1..60}; do
        if kubectl get crd clusters.postgresql.cnpg.io >/dev/null 2>&1; then
          echo "CloudNativePG CRDs are available"
          break
        fi
        if [ $i -eq 60 ]; then
          echo "Timeout waiting for CloudNativePG CRDs"
          exit 1
        fi
        sleep 2
      done

      # Create PostgreSQL cluster
      cat <<EOF | kubectl apply -f -
      apiVersion: postgresql.cnpg.io/v1
      kind: Cluster
      metadata:
        name: bootstrap-postgresql
        namespace: bootstrap
      spec:
        instances: 1
        imageName: ghcr.io/cloudnative-pg/postgresql:17.5
        storage:
          size: 8Gi
          storageClass: local-path
        bootstrap:
          initdb:
            database: terraform_locks
            owner: postgres
            secret:
              name: bootstrap-postgresql-superuser
        resources:
          requests:
            memory: 256Mi
            cpu: 100m
          limits:
            memory: 512Mi
            cpu: 250m
      EOF

      # Wait for cluster to be ready
      echo "Waiting for PostgreSQL cluster to be ready..."
      kubectl wait --for=condition=Ready cluster/bootstrap-postgresql -n bootstrap --timeout=300s
    EOT
  }

  provisioner "local-exec" {
    when    = destroy
    command = "kubectl delete cluster bootstrap-postgresql -n bootstrap --ignore-not-found=true || true"
  }

  depends_on = [
    kubernetes_namespace.bootstrap,
    helm_release.cloudnative_pg_operator,
    kubernetes_secret.bootstrap_postgresql_superuser
  ]
}

# PostgreSQL superuser secret for CloudNativePG
resource "kubernetes_secret" "bootstrap_postgresql_superuser" {
  metadata {
    name      = "bootstrap-postgresql-superuser"
    namespace = "bootstrap"
  }

  data = {
    username = base64encode("postgres")
    password = base64encode(var.postgres_password)
  }

  type = "kubernetes.io/basic-auth"

  depends_on = [kubernetes_namespace.bootstrap]
}
