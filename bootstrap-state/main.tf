# Bootstrap State Infrastructure - Phase 1 ONLY
# Purpose: Foundation infrastructure for enterprise platform
# Creates: k3s + MinIO + PostgreSQL ONLY (foundation only)

terraform {
  required_version = ">= 1.7"

  required_providers {
    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = "~> 2.35"
    }
    helm = {
      source  = "hashicorp/helm"
      version = "~> 2.17"
    }
    null = {
      source  = "hashicorp/null"
      version = "~> 3.2"
    }
  }
}

# Map resource tiers to storage sizes
locals {
  tier_sizes = {
    small  = { minio = "10Gi", postgres = "8Gi" }
    medium = { minio = "50Gi", postgres = "20Gi" }
    large  = { minio = "100Gi", postgres = "50Gi" }
  }
  minio_size    = local.tier_sizes[var.resource_tier].minio
  postgres_size = local.tier_sizes[var.resource_tier].postgres
}

# Dedicated namespaces for namespace isolation
# NOTE: k3s installation handled by bootstrap-phase1.sh script

resource "kubernetes_namespace" "storage" {
  metadata {
    name = "storage"
    labels = {
      "app.kubernetes.io/managed-by" = "terraform"
      "purpose"                      = "storage-services"
      # MinIO Helm chart (5.0.15) doesn't support PSS restricted container security context
      # Using baseline as a practical compromise - still provides security controls
      "pod-security.kubernetes.io/enforce"         = "baseline"
      "pod-security.kubernetes.io/enforce-version" = "latest"
      "pod-security.kubernetes.io/audit"           = "restricted"
      "pod-security.kubernetes.io/audit-version"   = "latest"
      "pod-security.kubernetes.io/warn"            = "restricted"
      "pod-security.kubernetes.io/warn-version"    = "latest"
    }
  }
}

resource "kubernetes_namespace" "databases" {
  metadata {
    name = "databases"
    labels = {
      "app.kubernetes.io/managed-by"               = "terraform"
      "purpose"                                    = "database-services"
      "pod-security.kubernetes.io/enforce"         = "restricted"
      "pod-security.kubernetes.io/enforce-version" = "latest"
      "pod-security.kubernetes.io/audit"           = "restricted"
      "pod-security.kubernetes.io/audit-version"   = "latest"
      "pod-security.kubernetes.io/warn"            = "restricted"
      "pod-security.kubernetes.io/warn-version"    = "latest"
    }
  }
}

resource "kubernetes_namespace" "minio" {
  metadata {
    name = "minio"
    labels = {
      "app.kubernetes.io/managed-by"               = "terraform"
      "purpose"                                    = "minio-admin"
      "pod-security.kubernetes.io/enforce"         = "restricted"
      "pod-security.kubernetes.io/enforce-version" = "latest"
      "pod-security.kubernetes.io/audit"           = "restricted"
      "pod-security.kubernetes.io/audit-version"   = "latest"
      "pod-security.kubernetes.io/warn"            = "restricted"
      "pod-security.kubernetes.io/warn-version"    = "latest"
    }
    annotations = {
      "description" = "Admin-only namespace for Vault's MinIO credentials (chicken-egg resolution)"
    }
  }
}

# MinIO credentials are generated by bootstrap script
# and passed as variables to this Terraform configuration

# MinIO for Terraform state storage (deployed to storage namespace)
resource "helm_release" "minio" {
  name       = "minio"
  repository = "https://charts.min.io/"
  chart      = "minio"
  namespace  = "storage"
  version    = "5.0.15"

  create_namespace = false  # Namespace created above

  values = [yamlencode({
    mode     = var.node_count == 1 ? "standalone" : "distributed"
    replicas = var.node_count
    rootUser     = var.minio_root_user
    rootPassword = var.minio_root_password
    buckets = [
      {
        name   = "terraform-state"
        policy = "none"
        purge  = false
      },
      {
        name   = "vault-storage"
        policy = "none"
        purge  = false
      }
    ]
    persistence = {
      enabled      = true
      size         = local.minio_size
      storageClass = "local-path"
    }
    service = {
      type = "ClusterIP"
      ports = {
        api     = 9000
        console = 9001
      }
    }
    resources = {
      requests = {
        memory = "256Mi"
        cpu    = "100m"
      }
      limits = {
        memory = "512Mi"
        cpu    = "500m"
      }
    }
    # Pod-level security context (chart supports these)
    # Note: MinIO Helm chart 5.0.15 doesn't support PSS restricted container security context
    # Storage namespace uses PSS baseline instead (see namespace labels above)
    securityContext = {
      enabled   = true
      runAsUser  = 1000
      runAsGroup = 1000
      fsGroup    = 1000
    }
  })]

  depends_on = [kubernetes_namespace.storage]
}

# CloudNativePG Operator for PostgreSQL management
resource "helm_release" "cloudnative_pg_operator" {
  name       = "cloudnative-pg"
  repository = "https://cloudnative-pg.github.io/charts"
  chart      = "cloudnative-pg"
  namespace  = "cnpg-system"
  version    = "0.22.1"

  create_namespace = true
  wait             = true
  timeout          = 600

  values = [yamlencode({
    resources = {
      requests = {
        cpu    = "100m"
        memory = "128Mi"
      }
      limits = {
        cpu    = "500m"
        memory = "256Mi"
      }
    }
  })]

  depends_on = [kubernetes_namespace.databases]
}

# PostgreSQL cluster for state locking (ARM64 compatible)
# Note: Deployed via null_resource because kubernetes_manifest validates CRDs at plan time
resource "null_resource" "postgresql" {
  provisioner "local-exec" {
    command = <<-EOT
      # Wait for operator to be ready
      echo "Waiting for CloudNativePG operator to be ready..."
      for i in {1..60}; do
        if kubectl get crd clusters.postgresql.cnpg.io >/dev/null 2>&1; then
          echo "CloudNativePG CRDs are available"
          break
        fi
        if [ $i -eq 60 ]; then
          echo "Timeout waiting for CloudNativePG CRDs"
          exit 1
        fi
        sleep 2
      done

      # Get tf-user password from secret
      TF_USER_PASSWORD=$(kubectl get secret postgresql-tf-user -n databases -o jsonpath='{.data.password}' | base64 -d)

      # Create PostgreSQL cluster in databases namespace
      cat <<EOF | kubectl apply -f -
      apiVersion: postgresql.cnpg.io/v1
      kind: Cluster
      metadata:
        name: postgresql
        namespace: databases
      spec:
        instances: 1
        imageName: ghcr.io/cloudnative-pg/postgresql:17.5
        storage:
          size: ${local.postgres_size}
          storageClass: local-path
        bootstrap:
          initdb:
            database: terraform_locks
            owner: postgres
            secret:
              name: postgresql-superuser
            postInitSQL:
              - CREATE USER "tf-user" WITH PASSWORD '$TF_USER_PASSWORD'
            postInitApplicationSQL:
              - GRANT CONNECT ON DATABASE terraform_locks TO "tf-user"
              - GRANT USAGE ON SCHEMA public TO "tf-user"
              - GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO "tf-user"
              - ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO "tf-user"
        resources:
          requests:
            memory: 256Mi
            cpu: 100m
          limits:
            memory: 512Mi
            cpu: 250m
      EOF

      # Wait for cluster to be ready
      echo "Waiting for PostgreSQL cluster to be ready..."
      kubectl wait --for=condition=Ready cluster/postgresql -n databases --timeout=300s
    EOT
  }

  provisioner "local-exec" {
    when    = destroy
    command = "kubectl delete cluster postgresql -n databases --ignore-not-found=true || true"
  }

  depends_on = [
    kubernetes_namespace.databases,
    helm_release.cloudnative_pg_operator,
    kubernetes_secret.postgresql_superuser,
    kubernetes_secret.postgresql_tf_user
  ]
}

# PostgreSQL superuser secret for CloudNativePG (in databases namespace)
resource "kubernetes_secret" "postgresql_superuser" {
  metadata {
    name      = "postgresql-superuser"
    namespace = "databases"
  }

  data = {
    username = "postgres"
    password = var.postgres_password
  }

  type = "kubernetes.io/basic-auth"

  depends_on = [kubernetes_namespace.databases]
}

# PostgreSQL tf-user secret (least privilege: terraform_locks only)
resource "kubernetes_secret" "postgresql_tf_user" {
  metadata {
    name      = "postgresql-tf-user"
    namespace = "databases"
  }

  data = {
    username = "tf-user"
    password = var.postgres_tf_password
  }

  type = "kubernetes.io/basic-auth"

  depends_on = [kubernetes_namespace.databases]
}
